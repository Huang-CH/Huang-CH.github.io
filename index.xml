<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on 黄 超 | H&amp;C</title>
    <link>https://Huang-CH.github.io/</link>
    <description>Recent content in 首页 on 黄 超 | H&amp;C</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://Huang-CH.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Python基础数据类型# Python数据类型的分类（按照可变与不可变进行分类）：
可变（不可哈希）的数据类型：列表（list）、字典（dict）、集合（set）
不可变（可哈希）的数据类型：字符串（str）、数值（int）、布尔值（bool）、元组（tuple）
 按照存储空间从低到高排序
  数字
  字符串
  集合（无序，即无索引相关信息）
  元组（有序，需要存储索引相关信息，不可变）
  列表（有序，需要存储索引相关信息，可变，需要处理数据的增、删、改等操作）
  字典（3.6之后有序，需要存储key与value的相关信息，可变，需要处理数据的增、删、改等操作）
 数字 &amp;lt; 字符串 &amp;lt; 集合 &amp;lt; 元组 &amp;lt; 列表 &amp;lt; 字典
    按照存值类型区分
 非容器型/原子类型：数字、字符串 容器型：元组、列表、字典   按照可变类型区分
 不可变类型：数字、字符串、布尔值、元组 可变类型：列表、字典   按照访问顺序区分
  直接访问：数字
  顺序访问（序列类型）：字符串、元组、列表
  键值访问（映射类型）：字典
键值访问的效率远高于顺序访问，但占用的存储空间也更大。
   int# 数值类型</description>
    </item>
    
    <item>
      <title>Go语言编程基础</title>
      <link>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
      <description>Go语言编程基础# 数据类型# 基础数据类型#Go语言数据类型可用于参数和变量的声明，主要有以下几种数据类型：
 布尔类型#布尔型的值只可以是常量True或者False，例如：var b bool = true
 数字类型#Go语言支持整型（int）和浮点型（float32、float64）数字，并且原生支持复数，其中位的运算采用补码。
整形数据   关键字 是否有符号 长度（范围）     uint8 无符号 8为整型（0~255）   uint16 无符号 16位整型（0~65535）   uint32 无符号 32位整型（0~4294967295）   uint64 无符号 64位整型（0~18446744073709551615）   int8 有符号 8位整型（-128~127）   int16 有符号 16位整型（-32768~32767）   int32 有符号 32位整型（-2147483648~2147483647）   int64 有符号 64位整型（-9223372036854775808~-9223372036854775807）    其他整型   关键字 说明     byte 类似uint8，8位   rune 类似int32，32位   uint 32或64位无符号类型，与系统有关   int 32或64位有符号类型，与系统有关   uintptr 无符号整型，用于存放一个指针    浮点型   关键字 说明     float32 IEEE-754 32位浮点型   float64 IEEE-754 64位浮点型     浮点数能够标识的范围可以从很小到很大，这个极限值范围可以在math包中获取，math.</description>
    </item>
    
    <item>
      <title>Rsync</title>
      <link>https://Huang-CH.github.io/docs/Linux/Basic-Operation/Rsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/Basic-Operation/Rsync/</guid>
      <description>Rsync# Rsync是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具。并且可以不进行改变原有数据的属性信息，实现数据的备份迁移特性。Rsync软件适用于Unix/Linux/Windows等多种操作系统平台。
Rsync是一个快速和非常通用的文件复制工具。它能本地复制，远程复制，或者远程守护进程方式复制。它提供了大量的参数来控制其行为的各个方面，并且允许非常灵活的方式来实现文件的传输复制。它以其delta-transfer算法闻名。减少通过网络数据发送数量，利用只发送源文件和目标文件之间的差异信息，从而实现数据的增量同步复制。
Rsync被广泛使用在备份和镜像，以及作为一种改进后的复制命令用于日常应用。
 提示信息： 官方链接资料：http://www.samba.org/ftp/rsync/rsync.html 官方手册资料：man rsync/man rsync.conf
  Rsync的作用# Rsync英文全称为Remote Synchronization，从软件的名称就可以看出来，Rsync具有可使本地和远程两台主机之间的数据快速复制同步镜像、远程备份的功能，这个功能类似SSH的scp命令，但又优于scp命令的功能，scp每次都是全量拷贝，而rsync可以增量拷贝。当然，Rsync还可以在本地主机的不同分区或目录之间全量及增量的复制数据，这又类似cp命令，但同样也优于cp命令，cp每次都是全量拷贝，而raync可以增量拷贝。
Rsync命令除了作为本地和远程复制命令使用以外，还可以作为删除和查看命令被应用，在某种情况下类似于传统的rm和ls命令。 通过上面文字的介绍，可以总结一下rsync命令的主要作用分为以下4种：
  实现本地数据同步复制（等价cp命令）
# 使用cp进行文件拷贝 cp -a /etc/hosts /temp/hosts_cp # 使用rsync实现cp功能 rsync -a /etc/hosts /temp/hosts_rsync # 注意：当使用rsync同步目录时如果目录后面带/，则同步的是目录中内容 rsync -a /etc/ /temp/ # 同步的是/etc/下的所有文件到/temp/中 rsync -a /etc /temp/ # 这才是将/etc文件夹备份到/temp/中   实现远程数据同步复制（等价scp命令）
# 使用scp实现远程数据复制 scp -rp /etc/hosts 192.168.1.100:/temp/hosts_scp # 使用rsync实现scp功能 rsync -rp /etc/hosts 192.168.1.100:/temp/hosts_rsync   实现数据信息删除功能（等价rm命令）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid>
      <description>字符编码# 字符编码记录的是二进制与字符的对应关系。
 常见的字符编码# ASCII：包含英文字母、数字和特殊字符与二进制的的对应关系。一个字符占用1个字节。
示例：a：01000001
 GBK：包含本国文字、英文字母、数字和特殊字符与二进制的对应关系。一个英文字符占用1个字节，一个中文字符占用2个字节。
示例：
a：01000001
中：01001001 01000010
 Unicode：也被称作“万国码”，包含全世界的所有文字、数字和特殊字符与二进制的对应关系。一个字符占用4个字节。
示例：
a：01000001 01000010 01000011 00000001
中：01001001 01000010 01100011 00000001
 UTF-8：包含全世界所有的文字、数字和特殊字符与二进制的对应关系。一个英文字符占用1个字节，一个欧洲字符占用2两字节，一个亚洲字符占用3个字节。
示例：
a：01000001
To（欧洲字符）：01000001 01000010
中（亚洲字符）：01001001 01000010 01100011
  知识点：在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或需要使用网络传输的时候，就转换为非Unicode编码，例如：Linux上的UTF-8编码或者Windows上的GBK编码。Python中所有的数据类型在内存中都使用Unicode编码，当需要存储到硬盘或使用网络传输时，需要将内存中Unicode编码的数据类型转换成非Unicode编码的bytes数据类型
  </description>
    </item>
    
    <item>
      <title>Go语言WEB开发</title>
      <link>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80WEB%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80WEB%E5%BC%80%E5%8F%91/</guid>
      <description>Go语言WEB开发# Go语言标准库之template#html/template  包实现了数据驱动的模板，用于生成安全的、可防止代码注入的HTML内容。它提供了和 text/template 包相同的接口，Go语言中输出HTML的场景都应使用 html/template 这个包。
 Go语言模板与渲染#在一些前后端不分离的Web架构中，我们通常需要在后端将一些数据渲染到HTML文档中，从而实现动态的网页（网页的布局和样式大致一样，但展示的内容并不一样）效果。
我们这里说的模板可以理解为事先定义好的HTML文档文件，模板渲染的作用机制可以简单理解为文本替换操作–使用相应的数据去替换HTML文档中事先准备好的标记。
很多编程语言的Web框架中都使用各种模板引擎，比如Python语言中Flask框架中使用的jinja2模板引擎。
 Go语言模板引擎#Go语言内置了文本模板引擎text/template和用于HTML文档的html/template。它们的作用机制可以简单归纳如下：
  模板文件通常定义为.tmpl和.tpl为后缀（也可以使用其他的后缀），必须使用UTF8编码。
  模板文件中使用{{和}}包裹和标识需要传入的数据。
  传给模板这样的数据就可以通过点号（.）来访问，如果数据是复杂类型的数据，可以通过{ { .FieldName }}来访问它的字段。
  除{{和}}包裹的内容外，其他内容均不做修改原样输出。
   Go语言模板引擎的使用#Go语言模板引擎的使用可以分为三部分：定义模板、解析模板和渲染模板。
 定义模板#其中，定义模板文件时需要我们按照相关语法规则去编写，后文会详细介绍。
 解析模板#定义好了模板文件之后，可以使用下面的常用方法去解析模板文件，得到模板对象：
func (t *Template) Parse(src string) (*Template, error) // 解析字符串中的模板 func ParseFiles(filenames ...string) (*Template, error) // 解析一个或多个文件中的模板 func ParseGlob(pattern string) (*Template, error) // 使用正则匹配解析多个文件中的模板  当然，你也可以使用 func New(name string) *Template 函数创建一个名为 name 的模板，然后对其调用上面的方法去解析模板字符串或模板文件。</description>
    </item>
    
    <item>
      <title>NFS</title>
      <link>https://Huang-CH.github.io/docs/Linux/Basic-Operation/NFS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/Basic-Operation/NFS/</guid>
      <description>NFS#  NFS(Network File System)网络文件系统
  NFS的优缺点# 优点
 简单、稳定、可靠   缺点
 存在单点故障，如果NFS Server宕机所有客户端均不能访问共享目录，可通过负载均衡和高可用方案弥补； 在大数据高并发的场合，NFS效率/性能有限（一般几千万PV以下不是瓶颈，除非网站架构太差，web、数据库、存储前都没有缓存机制）； 客户端认证时基于IP地址和主机名称，权限是根据ID识别，安全性一般（用于局域网中问题不大）； NFS数据是明文的，NFS本身对数据不做验证； 多台客户端挂载一个NFS服务器时，管理维护麻烦（耦合度高），尤其是NFS服务端出问题后，所有NFS客户端都会挂掉   安装NFS和RPC服务# 在服务端和客户端上，安装NFS和RPC服务
yum -y install nfs-utils rpcbind 在服务端和客户端上，检查安装的NFS、RPC服务
rpm -aq nfs-utils rpcbind  启动NFS、RPC服务# 先启动RPC服务，一定要先启动RPC服务！
# /etc/init.d/rpcbind start systemctl start rpcbind.service 检查RPC服务启动状态
# /etc/init.d/rpcbind status systemctl status rpcbind.service 查看占用端口的服务，RPC主端口为：111
# lsof -i :111 netstat -lntup | grep rpcbind 设置NFS开机自启动，建议将启动命令写在/etc/rc.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>文件操作# 在Python中，可以使用内置函数open()对文件进行操作。
文件操作需要如下几个参数：
 文件路径：path 打开方式：mode， 打开方式有读、写、追加、读写 编码方式：encoding，UTF-8、GBK、GB2312等，内置函数open()中如果不声明encoding，则默认的编码方式与操作系统相同。   Python文件操作需要注意的是，以什么样的编码保存的，就必须以什么样的编码打开。
  文件操作的读# r 模式：读文件#  操作文本类文件，有五种读取方式
  方式一：将文件内容一次性全部读取到文件句柄，文件句柄是一个迭代器（★）
f = open(r&amp;#39;文本文件的路径&amp;#39;, mode = &amp;#39;r&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;)	# encoding只是声明编码方式 content = f.read()	# f称之为“文件句柄”，对文件的任何操作都需要通过 文件句柄. 的方式 print(content) f.close()  方式二：按照指定的字符个数读取文件内容
f = open(r&amp;#39;文本文件的路径&amp;#39;, mode = &amp;#39;r&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;) content = f.read(10) # f.read(10)表示读取文件的前10个字符 print(content) f.close()  方式三：按照行读取文件内容，读取一行
f = open(r&amp;#39;文本文件的路径&amp;#39;, mode = &amp;#39;r&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;) content = f.</description>
    </item>
    
    <item>
      <title>Go语言的ORM框架</title>
      <link>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80%E7%9A%84ORM%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Golang/Go%E8%AF%AD%E8%A8%80%E7%9A%84ORM%E6%A1%86%E6%9E%B6/</guid>
      <description>Go语言的ORM框架# GORM简介#GORM是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。
中文官方网站：https://gorm.io/zh_CN/
官方中文文档：https://gorm.io/zh_CN/docs/
 GORM安装#// 安装 GORM 框架 go get -u gorm.io/gorm // 安装 MySQL 数据库驱动 go get -u gorm.io/driver/mysql // 安装 SQL Server 数据库驱动 go get -u gorm.io/driver/mssql // 安装 PostgreSQL 数据库驱动 go get -u gorm.io/driver/postgres // 安装 SQLite 数据库驱动 go get -u gorm.io/driver/sqlite // 安装 Oracle 数据库驱动 go get github.com/CengSin/oracle  GORM连接数据库#GORM连接MySQL#import ( &amp;#34;gorm.</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://Huang-CH.github.io/docs/Linux/Basic-Operation/Nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/Basic-Operation/Nginx/</guid>
      <description>安装环境依赖# 安装PCRE# 检查PCRE是否安装
rpm -qa pcre pcre-devel 安装PCRE和PCRE库（正则表达式兼容模块），一般来说安装pcre-devel即可
yum install -y pcre pcre-devel  安装OpenSSL# 检查openssl是否安装
rpm -qa openssl openssl-devel 安装openssl和openssl库（实现https访问），一般来说安装openssl-devel即可
yum install -y openssl openssl-devel  安装其他依赖# yum install -y gcc gcc-c++ kernel-devel  安装Nginx# 检查Nginx是否安装
rpm -qa nginx 进入opt目录
cd /opt/ 下载Nginx安装包
wget http://nginx.org/download/nginx-1.16.1.tar.gz 解压Nginx安装包
tar -zxvf nginx-1.16.0.tar.gz 创建Nginx的软连接
ln -s /opt/nginx-1.16.0 /opt/nginx 进入Nginx文件夹</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>名称空间# 名称空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。
名称空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。
Python中存在三种名称空间：
 内置名称空间：Python内置名称，如内置函数：print、hash、input和异常名称BaseException、Exception等等。 全局名称空间：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。即一个python文件中的所有名称。 局部名称空间：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量（类中定义的也是如此）。局部名称空间是一个临时的名称空间，调用函数或类的时后产生，函数或类内部的代码执行完毕后，局部名称空间随着函数或类的结束而消失。   名称空间的顺序# 名称空间的加载顺序：内置名称空间 -&amp;gt; 全局名称空间 -&amp;gt; 局部名称空间（执行函数时）
名称空间的取值顺序：局部空间 -&amp;gt; 全局名称空间 -&amp;gt; 内置名称空间。遵循就近取值原则
 作用域# 作用域就是一个 Python 程序可以直接访问名称空间的区域。
Python 中存在两种作用域：
 全局作用域：内置名称空间 + 全局名称空间。使用globals() 函数会以字典类型返回当前位置的全部全局变量。 局部作用域：局部名称空间。使用locals() 函数会以字典类型返回当前位置的全部局部变量。   作用域的访问规则# Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。局部作用域可以访问全局作用域的变量，但不能修改全局作用域的变量（可变数据类型，例如列表、字典等可以更改），而全局作用域的变量不能访问局部作用域的变量。
 全局变量与局部变量的转换# global：将局部变量转换成全局变量，并且可以修改全局变量。
def func(): name = &amp;#39;Python&amp;#39; print(name) # 可以打印 func() print(name)	# 报错！在全局作用域中找不到局部作用域中的变量 # 使用global声明，将局部变量转换成全局变量 def func(): global name name = &amp;#39;Python&amp;#39; print(name) func() print(name)	# 可以打印，通过global name将name变为了全局变量。 # 使用global声明，在函数内部修改全局变量 count = 1 def func(): global count count += 1 print(count)	# 输出结果：1 func() print(count)	# 输出结果：2  nonlocal：不能操作全局变量。用于局部作用域中内层函数对外层函数的局部变量进行修改。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%87%BD%E6%95%B0/</guid>
      <description>什么是函数# 函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码段。
 为什么要用函数# 函数能提高应用的模块性和代码的重复利用率。
 如何定义函数# 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()，圆括号之间可以用于定义参数；
函数内容以冒号起始，并且缩进；
函数的第一行语句一般使用多行注释来阐述函数的作用；
return [表达式]结束函数，选择性地返回一个值给调用方。返回值可以是单个值，也可以是被元组包裹的多个值，不带表达式的return相当于返回None。
函数内尽量避免使用print()。
def func(): &amp;#39;&amp;#39;&amp;#39; 描述一下这个函数是干什么的 :return: &amp;#39;&amp;#39;&amp;#39; pass  函数的调用# 当定义一个函数后，函数内的所有代码都不会执行，只有调用函数时函数才会被执行
def func(): &amp;#39;&amp;#39;&amp;#39; 描述一下这个函数是干什么的 :return: &amp;#39;&amp;#39;&amp;#39; pass func()	# 只有调用函数的时候，函数内的代码才会执行  函数的参数# 函数的参数分为实参和形参，实参是调用函数时传入的参数，形参是定义函数时定义的参数。
def func(a):	# a就是形参 &amp;#39;&amp;#39;&amp;#39; 描述一下这个函数是干什么的 :return: &amp;#39;&amp;#39;&amp;#39; pass func(&amp;#39;实参&amp;#39;)  函数的实参分为3种：位置实参、关键字实参和混合实参。
 位置实参：安照顺序传值，从左到右，与形参一一对应
def func(a, b):	# a = 1，b = 2 &amp;#39;&amp;#39;&amp;#39; 描述一下这个函数是干什么的 :return: &amp;#39;&amp;#39;&amp;#39; pass func(1, 2)	# 位置形参安照顺序传值，从左到右，与形参一一对应  关键字实参：按照关键字对形参进行传值</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>可迭代对象# 内部含有__iter__方法的对象，称之为可迭代对象。
 通过dir()获取一个对象内部的所有方法
s = &amp;#39;Python&amp;#39; print(dir(s))	# 返回对象s内部的所有方法 &amp;#39;&amp;#39;&amp;#39; 输出结果： [&amp;#39;__add__&amp;#39;, &amp;#39;__class__&amp;#39;, &amp;#39;__contains__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__dir__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__eq__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__ge__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__getitem__&amp;#39;, &amp;#39;__getnewargs__&amp;#39;, &amp;#39;__gt__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__init_subclass__&amp;#39;, &amp;#39;__iter__&amp;#39;, &amp;#39;__le__&amp;#39;, &amp;#39;__len__&amp;#39;, &amp;#39;__lt__&amp;#39;, &amp;#39;__mod__&amp;#39;, &amp;#39;__mul__&amp;#39;, &amp;#39;__ne__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__rmod__&amp;#39;, &amp;#39;__rmul__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;capitalize&amp;#39;, &amp;#39;casefold&amp;#39;, &amp;#39;center&amp;#39;, &amp;#39;count&amp;#39;, &amp;#39;encode&amp;#39;, &amp;#39;endswith&amp;#39;, &amp;#39;expandtabs&amp;#39;, &amp;#39;find&amp;#39;, &amp;#39;format&amp;#39;, &amp;#39;format_map&amp;#39;, &amp;#39;index&amp;#39;, &amp;#39;isalnum&amp;#39;, &amp;#39;isalpha&amp;#39;, &amp;#39;isascii&amp;#39;, &amp;#39;isdecimal&amp;#39;, &amp;#39;isdigit&amp;#39;, &amp;#39;isidentifier&amp;#39;, &amp;#39;islower&amp;#39;, &amp;#39;isnumeric&amp;#39;, &amp;#39;isprintable&amp;#39;, &amp;#39;isspace&amp;#39;, &amp;#39;istitle&amp;#39;, &amp;#39;isupper&amp;#39;, &amp;#39;join&amp;#39;, &amp;#39;ljust&amp;#39;, &amp;#39;lower&amp;#39;, &amp;#39;lstrip&amp;#39;, &amp;#39;maketrans&amp;#39;, &amp;#39;partition&amp;#39;, &amp;#39;replace&amp;#39;, &amp;#39;rfind&amp;#39;, &amp;#39;rindex&amp;#39;, &amp;#39;rjust&amp;#39;, &amp;#39;rpartition&amp;#39;, &amp;#39;rsplit&amp;#39;, &amp;#39;rstrip&amp;#39;, &amp;#39;split&amp;#39;, &amp;#39;splitlines&amp;#39;, &amp;#39;startswith&amp;#39;, &amp;#39;strip&amp;#39;, &amp;#39;swapcase&amp;#39;, &amp;#39;title&amp;#39;, &amp;#39;translate&amp;#39;, &amp;#39;upper&amp;#39;, &amp;#39;zfill&amp;#39;] &amp;#39;&amp;#39;&amp;#39;  判断一个对象是不是一个可迭代对象（检查一个对象中是否含有__iter__方法）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>生成器# 在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。
 生成器和迭代器的区别# 生成器是我们用Python代码构建的数据结构。而迭代器都是Python提供或者转换得来的。
 获取生成器# 获取生成器有3种方式：通过生成器函数获取生成器、通过生成器表达式获取生成器和Python内置函数或模块
 通过生成器函数获取生成器
只要函数中使用了yield关键字，这个函数就是生成器函数，生成器函数使用函数名称()不执行生成器函数。在生成器函数内部，通过关键字yield生成需要返回的值；生成器函数外，通过next(调用生成器函数)来获取一个yield的值，获取yield值的过程中，执行yield关键字之上的所有代码，直到遇到yield停止代码的执行（但不会结束函数），返回yield的值，注意，使用一个next(调用函数)，对应获取一个yield值。
def func(): print(&amp;#39;Python&amp;#39;) yield &amp;#39;第一个yield&amp;#39; print(&amp;#39;生成器&amp;#39;) yield &amp;#39;第二个yield&amp;#39; a = 1 b = 2 c = a + b print(c) yield &amp;#39;第三个yield&amp;#39; ret = func() print(next(ret)) # 输出结果：第一个yield print(next(ret)) &amp;#39;&amp;#39;&amp;#39; 输出结果： Python生成器 第二个yield &amp;#39;&amp;#39;&amp;#39; print(next(ret)) &amp;#39;&amp;#39;&amp;#39; 输出结果： 3 第三个yield &amp;#39;&amp;#39;&amp;#39; # 如果next()和yield的调用次数不对应，会报错！&amp;#39;StopIteration(停止迭代)&amp;#39; # yiled form def func(): l = [1,2,3,4,5] yield from l # l将作为子生成器为next(ret)返回列表中的单一元素 ret = func() print(next(ret)) print(next(ret)) print(next(ret)) print(next(ret)) print(next(ret)) print(next(ret)) &amp;#39;&amp;#39;&amp;#39; 输出结果： 1 2 3 4 5 Traceback (most recent call last): File &amp;#34;C:/Users/BDHT/OneDrive/Python/Python3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%A8%A1%E5%9D%97/</guid>
      <description>模块# Python模块(Module)，本质就是一个Python文件，以 .py 结尾，包含了Python对象定义和Python语句，是封装语句的最小单位。一个模块就是就是包含了一组功能的Python文件，比如spam.py，模块名为spam，可以通过 import spam 调用模块。模块不宜过大，不便于维护。
 模块的分类# 在Python中，模块的使用方法都是一样的，可以细分为四个通用类别：
 使用Python编写的.py文件 已被编译为共享库或DLL的C或C++扩展 把一系列模块组织到一起的文件夹（注：该文件夹下有一个 __init__.py 文件，该文件夹称之为包，导入一个包相当于执行了这个包下的__init__.py文件，并不是把这个包下的所有文件都导入进来） 使用C语言编写，并链接到Python解释器的内置模块   使用模块的意义# 模块让你能够有逻辑地组织你的 Python 代码段；把相关的代码分配到一个模块里能让你的代码更好用，更易懂；模块能定义函数，类和变量，模块里也能包含可执行的代码；拿来主义，提升开发效率。
 自定义模块# 本质就是创建一个Python文件。自定义模块开头应注释说明自定义模块的作用，以下是time模块的注释说明
# encoding: utf-8 # module time # from (built-in) # by generator 1.147 &amp;#34;&amp;#34;&amp;#34; This module provides various functions to manipulate time values. There are two standard representations of time. One is the number of seconds since the Epoch, in UTC (a.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>什么是正则表达式# 正则表达是一套匹配字符串的通用规则，很多开发语言中都有。
 为什么要用正则表达式# 检测一个字符串是否合法。在用户输入一个内容的时候，应该对用户输入的内容做检测，这样才能规避因用户的错误或恶意输入，对程序和服务器造成的资源浪费。多用于在Web项目开发时，用于表单验证。
高效的内容匹配。从一个大文件当中快速的找到所有符合规则的内容。多用于爬虫的日志分析。
 正则表达式怎么用# 正则表达式永远都是从左到右依据规则进行匹配的，正则表达式没有逻辑，只认规则！有逻辑的永远是正则表达式的设计者！
 字符组# 字符组是整个正则表达式中描述最细腻的方式，可以精准的匹配到任何内容。
[]：一个中括号内放入需要匹配的的字符，只要被匹配的字符串内单个字符位置含有中括号里的ASCII字符，就算匹配成功。中括号内可以写一个、多个、一个范围或者多个范围的字符，字符的范围需根据ASCII码值中从小到大，不能从大到小。
[Python]	# 匹配P，y，t，h，o，n这6个字母，只匹配一个字符位 [a-z]	# 匹配a到z所有的字母，由于根据ASCII码进行匹配，因此范围需要ACSII码从小到大，不能z-a [A-z]	# 匹配A到Z所有的字母 [0-9]	# 匹配0到9所有的数字 [0-9a-zA-Z]	# 匹配所有大小写字母与数字，可以写多个范围  非字符组# [^]：一个中括号，第一位是^，表示非字符组。
[^Python]	# 只要匹配内容中不是P，y，t，h，o，n这6个字母，那个字节位就算匹配成功  元字符# 在正则表达式中表示匹配的内容符号（字符组、\d、\w、\s等）都是元字符。表示能匹配那些内容，一个元字符只能表示一个字符位置上的字符。
\d：表示匹配一位任意数字字符，等同于 [0-9]。d表示digit。
\w：表示匹配一位任意数字字符、字母和下划线，等同于 [0-9a-zA-Z_]。w表示word。
\s：表示匹配一位任意空字符（空格： ，制表符：\t，回车：\n）。
\D：表示匹配一位任意非数字字符。
\w：表示匹配一位任意非数字、字母和下划线字符。
\S：表示匹配一位任意非空白字符。
\b：表示以一个单词为边界匹配任意数字、字母和下划线结尾的字符。
.：表示匹配一位除换行符以外的任意字符。但可以通过设置使其能够匹配换行符。注意，如果匹配的字符串中含有.比如：www.google.com，那么需要在规则的.之前加上\进行转义：\.，否则.所占的字符位就会匹配除换行符以外的任意字符。
[\d\D]、[\w\W]、[\d\D]：表示匹配一位任意字符。
^：匹配字符串的开始。注意：^只能出现在开始的位置，且只从字符串的开始位置进行匹配，进行匹配时，空白字符由于看到不，经常会被忽略，所以要格外注意，空白字符也要算上。
$：匹配字符串的结尾。注意：$只能出现在结束的位置，且只从字符串的结束位置进行匹配，进行匹配时，空白字符由于看到不，经常会被忽略，所以要格外注意，空白字符也要算上。
^和$组合使用：约束了在^和&amp;amp;之间的所有字符和字符位，被匹配字符串必须和^ &amp;amp;之间的字符一模一样才算匹配成功。主要用于判断用户输入内容的合法性检查。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8Bre%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8Bre%E6%A8%A1%E5%9D%97/</guid>
      <description>re模块介绍# re  模块使 Python 语言拥有全部的正则表达式功能。
 re模块的内置方法# re.findall()#对字符串进行正则表达式的全文匹配，把所有符合正则表达式的结果以列表的形式返回，如果正则表达式中有分组，虽然匹配的时候按照正则表达式进行匹配的，但是只返回分组中的正则内容。
import requests s = &amp;#39;&amp;lt;h1&amp;gt;Python之re模块findall方法&amp;lt;/h1&amp;gt;&amp;#39; # 通过正则只取出结果：&amp;#39;Python之re模块findall方法&amp;#39; ret = re.findall(&amp;#39;&amp;lt;h1&amp;gt;(.*?)&amp;lt;/h1&amp;gt;&amp;#39;,s)	# 有分组()时，返回结果只会显示分组内容 print(ret)	# [&amp;#39;Python之re模块findall方法&amp;#39;]  re.search()#对字符串进行正则表达式的全文匹配，只取第一个符合正则表达式条件的结果，得到的结果是一个变量，通过.group(n)可以获取到第n个分组中匹配到的内容。主要用来寻找字符串中是否含有满足条件的子内容。
import requests s = &amp;#39;4-2*(4+6)&amp;#39; # 通过正则计算s中4+6的值 ret = re.search(&amp;#39;(\d+)[+](\d+)&amp;#39;,s) ret_1 = int(ret.group(1)) ret_2 = int(ret.group(2)) print(ret_1 + ret_2)  re.split()#以正则表达式为条件，切分字符串内容，并将内容以列表的形式返回。若正则表达式中有分组，则保留匹配的切分条件。
# 不含分组 import re s = &amp;#39;54Python432re78split&amp;#39; ret = re.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向过程的编程思想# 面向过程的编程思想是按照步骤解决问题，即先干什么，后干什么。基于该思想编写程序，就好比编写一条流水线，是一种机械式思维方式，多用于运维。
 优点：复杂的问题流程化，进而简单化；
缺点：修改一个步骤，其他步骤都有可能做出修改，牵一发而动全身，扩展性极差。
 应用场景：应用于扩展性要求低的场景
 面向对象的编程思想# 面向对象程序设计方法是尽可能模拟人类的思维方式，使得软件的开发方法与过程尽可能接近人类认识世界、解决现实问题的方法和过程，也即使得描述问题的问题空间与问题的解决方案空间在结构上尽可能一致，把客观世界中的实体抽象为问题域中的对象。面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。
 优点：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。
缺点：
 编程的复杂度远高于面向过程，不了解面向对象而立即上手基于它设计程序，极容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会徒增编程难度，比如管理Linux系统的Shell脚本就不适合用面向对象去设计，面向过程反而更加适合。 无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，最终结果就无法进行准确地预测。于是我们经常看到对战类游戏，新增一个游戏人物，在对战的过程中极容易出现阴霸的技能，一刀砍死3个人，这种情况是无法准确预知的，只有对象之间交互才能准确地知道最终的结果。   应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性。
 Python的面向对象有三大特征：继承、封装和多态
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</guid>
      <description>类# 类是用来描述具有相同的属性和方法的对象的集合（在Python中类与类型是一个概念）。
 特点：
  在程序中，必须先定义类（类名称通常首字母大写），再调用类，然后产生对象；
  类（类体）中最常见的就是变量（类的数据属性或者叫做静态变量）与函数（函数属性或者叫做方法）的定义，但类中可以有任意Python代码，并且类体中的代码在类的定义阶段就会立即执行。在类中，如果一个变量的值需要被所有对象共享，那么这个变量应该被定义成静态变量，所有和静态变量相关的增、删、改、查都应该使用类名调用静态变量的方式来处理，而不应该使用对象名调用静态变量的方式进行处理。
  类的属性可以进行增、删、改、查等操作
  调用类产生对象的过程称为类的实例化，实例化的结果是一个对象，或者称为一个实例。
# For example: class Chinese(): # 类命名规则是首字母大写的驼峰体 &amp;#39;&amp;#39;&amp;#39; 类的注释信息 &amp;#39;&amp;#39;&amp;#39; country = &amp;#39;China&amp;#39; # 类内通常定义相同的特征，country被称为Chinese类中的数据属性 def __init__(self,name,age,sex): # 在对象实例化的时候，__init__() 会自动触发执行 self.Name = name # Chinese.Name = name self.Age = age # Chinese.Age = age self.Sex = sex # Chinese.Sex = sex def run(self): # 类内通常定义相同的技能；类内的函数()中默认自带self参数；run(self)称之为Chinese类中的绑定方法 print(F&amp;#39;{self.Name}is running&amp;#39;) obj = Chinese(&amp;#39;HC&amp;#39;, 18, &amp;#39;males&amp;#39;) # 类的实例化，Chinese.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%BB%84%E5%90%88/</guid>
      <description>组合# 一个类的对象是另一个类的属性。
 使用组合的意义# 减少代码冗余，让代码修改起来更灵活。
 组合的使用方法# # 定义一个笔记本电脑类 class Laptop: def __init__(self, brand, model): self.brand = brand # 品牌 self.model = model # 型号 # 定义一个供应商类 class Supplier: def __init__(self, supplier_name, supplier_price): self.supplier_name = supplier_name # 供应商名称 self.supplier_price = supplier_price # 供应商价格 # 创建一个ThinkPad的笔记本对象 thinkpad = Laptop(&amp;#39;Thinkpad&amp;#39;, &amp;#39;T490s&amp;#39;) # 创建一个JD供应商的对象 jd = Supplier(&amp;#39;JD&amp;#39;, 11000) # 利用组合查看thinkpad在jd中的价格 thinkpad.supplier = jd print(thinkpad.supplier.supplier_price) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%B0%81%E8%A3%85%E5%92%8C%E5%A4%9A%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%B0%81%E8%A3%85%E5%92%8C%E5%A4%9A%E6%80%81/</guid>
      <description>继承# 继承是一种新建类的方式，在Python中支持一个子类继承多个父类。继承是类与类之间的从属关系，寻找这种关系需要先抽象，再继承。新建的类称为子类或派生类，父类又称为基类或超类。子类会继承父类的属性，可以使用父类的静态变量和方法。继承其实增加了类的耦合性。
 使用继承的意义#减少代码冗余。
 继承的使用方法#在Python 2中类分为两种，一种叫经典类（没有继承了object类，以及该类的子类，查找顺序遵从深度优先），一种叫新式类（继承了object类，以及该类的子类，查找顺序遵从广度优先，新式类中使用类名.mro()可以查看C3算法）。但在Python 3中全都为新式类。类的继承分为两种，一种是单继承，单继承可以继承多次；一种是多继承，Python中支持多继承，但并不是所有语言都支持，使用多继承可以同时继承多个父类，查找顺序为先继承的先找。
# For Example： class ParentClass1: pass class ParentClass2: pass class SubClass1(ParentClass1): # 单继承 pass class SubClass2(ParentClass1,ParentClass2): #多继承，先从写在前面的父类中找 pass print(SubClass1.__bases__) # 查看SubClass的父类 print(SubClass2.__bases__) # 查看SubClass的父类 # For Example： class Father(object):	# 继承object这种写法可以兼容Python 2 def __init__(self): self.func() def func(self): print(&amp;#39;The func from Father&amp;#39;) class Son(Father):	# 子类Son会继承父类Father的所有属性和方法 def func(self):	print(&amp;#39;The func from Son&amp;#39;) son = Son()	# The func from Son # 注意：代码自上而下执行，定义Father类的时候，会开辟一个名称空间，将__init__和func放入Father类的名称空间；定义Son类的时候，也会开辟一个名称空间，程序读到class Son(Father)时会产生一个类指针，指向Father类的名称空间，同时将类指针和func存入Son的名称空间中；当程序读到son = Son()进行实例化产生对象的时候，同样也会为对象son开辟一个名称空间，产生一个类指针，指向Son类，并且实例化会自动触发__init__，首先会在对象son的名称空间找__init__，找不到，再去Son类中找，也没有，再通过类指针指向的Father中查找，找到了__init__，把son作为self传入到__init__中，此时，father中__init__的self实际上指向的时son的名称空间，当执行self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%8F%8D%E5%B0%84/</guid>
      <description>反射的定义# 通过字符串来操作类与对象的属性(attribute)、实例变量、绑定方法等操作，称之为反射。
 反射的作用# 想通过变量的字符串类型的名字，直接调用变量的时候，就需要用到反射。
 反射语法# 以下四个内置函数是专门通过字符串来操作类与对象属性的：
 hasattr(object, &#39;name&#39;) 函数用于判断name在不在类object中，等同于print(&#39;name&#39; in object.__dict__)。 getattr(object, &#39;name&#39;, None) 函数用于返回一个对象属性值，等于调用 object.name ,如果没有属性或属性没有值，就返回None，一般getattr()会与hasattr()成对出现。 setattr(object, &#39;name_1&#39;, &#39;name_2&#39;) 函数用于修改属性的值。 delattr(object, &#39;name&#39;) 函数用于删除属性的值。   object：对象
&amp;lsquo;name&amp;rsquo;：对象属性的字符串
  反射的使用方法（场景）# 反射对象的实例变量和绑定方法
class User(object): &amp;#39;&amp;#39;&amp;#39; 定义一个用户类 &amp;#39;&amp;#39;&amp;#39; def __init__(self): self.username = &amp;#39;徐凤年&amp;#39; self.password = &amp;#39;123&amp;#39; # 实例化 user = User() # 通过内置函数getatter()进行反射 徐凤年 = getattr(user, &amp;#39;username&amp;#39;) print(徐凤年)	# 得到的是self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%85%83%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%85%83%E7%B1%BB/</guid>
      <description>什么是元类# 类的类就是元类，元类创建对象。使用class定义的类，用来产生程序员自己的对象；而class定义的类，是由内置的元类type产生的。
class Chinese: # 默认的元类是type country = &amp;#39;China&amp;#39; def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex  使用class定义类等同于使用以下方式定义类：
class_name = &amp;#39;Chinese&amp;#39; class_base = (object,) # 基类为元组 class_body = &amp;#39;&amp;#39;&amp;#39; country = &amp;#39;China&amp;#39; def __init__(self, name, age, sex): self.name = name self.age = age elf.sex = sex &amp;#39;&amp;#39;&amp;#39; class_dic = {} exec(class_body, {}, class_dic) # 产生类的名称空间 # 类的三大要素，类名，基类，类的名称空间 Chinese = type(class_name, class_base, class_dic)  为什么要有元类# 控制类的创建和行为。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>什么是异常处理# 异常就是程序运行时发生错误的信号（在程序出现错误时，则会产生一个异常，若程序没有处理它，则会抛出该异常，程序的运行也随之终止）。一个异常分为三部分：异常的追踪信息，异常的类型，异常的值。
 异常的分类：
 语法异常：Python在执行代码前会检查语法，如果有语法异常，应该在程序执行前就改正。 逻辑异常：  AttributeError：试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x。 IOError：输入/输出异常；基本上是无法打开文件。 ImportError：无法引入模块或包；基本上是路径问题或名称错误。 IndentationError： 语法错误（的子类） ；代码没有正确对齐。 IndexError：下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]。 KeyError ：试图访问字典里不存在的键。 KeyboardInterrupt：Ctrl+C被按下。 NameError：使用一个还未被赋予对象的变量。 SyntaxError：Python代码非法，代码不能编译(个人认为这是语法错误，写错了）。 TypeError：传入对象类型与要求的不符合。 UnboundLocalError # 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它。 ValueError：传入一个调用者不期望的值，即使值的类型是正确的。     为什么会有异常处理# 为了保证程序的健壮性与容错性，即在遇到错误时程序不会崩溃，因此我们需要对异常进行处理。
 异常处理怎么用# 如果明确知道错误发生的条件是什么，我们需要用if进行处理（在错误发生之前进行预防）。
AGE = 10	# 字母大写，定义一个常量 while True: age = input(&amp;#39;&amp;gt;&amp;gt;: &amp;#39;).strip() if age.isdigit(): # 只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age = int(age) if age == AGE: print(&amp;#39;You Got It！&amp;#39;) break  如果不确定错误发生的条件是什么，则需要用到try.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E5%86%85%E7%BD%AE%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E5%86%85%E7%BD%AE%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</guid>
      <description>__call__方法# 在调用对象时（实例化的对象加括号），会自动触发类中的__call__方法。一个对象能不能在后面加括号调用，就看这个对象所在的这个类中有没有__call__方法。
class Foo(object): def __call__(self, *args, **kwargs): print(&amp;#39;自动触发__call__方法&amp;#39;) foo = Foo() foo() # 自动触发__call__方法  __len__方法# 使用len(obj)时，会自动触发类中的__len__方法。需要实现len(obj)这种用法时，类中就一定要有__len__方法。
class Foo(object): def __init__(self): self.list = [] def __len__(self): return len(self.list) foo = Foo() foo.list.append(1) foo.list.append(2) foo.list.append(3) print(len(foo.list)) # 3  __new__方法# __new__是一个构造方法，在实例化对象时为对象开辟的空间，创建的类指针，用的就是__new__方法。__new__方法常见于单例模式，即无论实例化多少次，都只开辟一次空间。
class Foo(object): __identification = None def __new__(cls, *args, **kwargs): if cls.__identification is None: cls.__identification = object.__new__(cls) return cls.__identification def __init__(self, name, age): self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>什么是socket# Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个“门面模式”，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
 基于文件类型的套接字家族：
套接字家族的名字：AF_UNIX Unix中一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。
 基于网络类型的套接字家族：
套接字家族的名字：AF_INET 还有AF_INET6被用于IPv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，Python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。
 为什么要用socket# 使用socket，我们无需深入理解TCP或UDP协议，socket已经为我们封装好了，我们只需要遵循socket的规则去编程，写出的程序自然就是遵循TCP或UDP标准的。
 基于TCP协议的socket（无并发）# 服务端
# tcp是基于可靠链接的，必须先启动服务端，然后再启动客户端去链接服务端 import socket # 由于 socket 模块中有太多的属性。因此可以使用&amp;#39;from module import *&amp;#39;语句。也就是 &amp;#39;from socket import *&amp;#39;,这样我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能大幅减短代码。 # from socket import * # socket_server = socket(AF_INET, SOCK_STREAM) socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建服务器套接字，SOCK_STREAM流式协议，指的是TCP协议；SCOK_DGRAM数据报协议,指的是UDP协议。 # socket_server = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM) socket_server.bind((&amp;#39;127.0.0.1&amp;#39;, 8080)) # 把地址绑定到套接字，只有服务端需要绑定，IP地址填写服务器IP，端口是数字类型，1025-65530任选，端口0-1024系统占用 socket_server.listen(5) # 监听链接，backlog = 5 表示同一时间能接受5个请求，并不是最大连接数 # 等待连接 conn, client_address = socket_server.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocketserver%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocketserver%E6%A8%A1%E5%9D%97/</guid>
      <description>socketserver模块与socket模块的关系# socketserver模块是基于socket模块开发的，socket模块是socketserver的底层模块。
 socketserver模块的用途# socketserver模块主要用来处理并发的TCP客户端请求。（如果自己能写出来比socketserver更好的模块，可以用自己的，但在此之前，所有的TCP服务端都应该使用socketserver模块）
 socketserver模块的使用方法（服务端）# import socketserver # 必须先自定义一个类,并且必须继承socketserver.BaseRequestHandler类 class MySocketServer(socketserver.BaseRequestHandler): # 必须定义个handle方法，所有客户端发起连接请求都会先调用handle()方法 def handle(self): conn = self.request # 与客户端建立连接 pass # 客户端连接成功后执行的代码，例如：登录、上传、下载等 # 多线程实例化对象 server = socketserver.ThreadingTCPServer((&amp;#39;127.0.0.1&amp;#39;,9000), MySocketServer) # 使程序一直运行 server.serve_forever()  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/</guid>
      <description>什么是进程# 进程是一个抽象的概念，进程的概念起源于操作系统，是正在进行的一个过程或者一个过程的总和，而负责执行过程的则是CPU。
 进程与程序的区别
程序仅仅只是一堆文件、一堆代码而已，而进程指的是程序的运行过程或过程的总和。即程序放在硬盘里没有运行叫做程序，程序运行起来就叫做进程。进程是计算机中最小的资源分配单位。
 并发与并行# 无论是并行还是并发，在用户看来都是“同时”运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是CPU，CPU来做这些任务，而一个CPU同一时刻只能执行一个任务。
**并发：**是伪并行，即看起来是同时运行。单个CPU + 多道技术就可以实现并发，也就是说多个程序轮流再一个CPU上执行，其本质仍是串行，只不过多个程序的切换的非常快，因此看起来就像是同时运行一样（并行也属于并发）。
**并行：**多个程序同时执行，并且是在多个CPU上同时执行的。因此只有具备多个CPU才能实现并行。
 多道技术# 多道技术中的多道指的是多个程序，多道技术的实现是为了解决多个程序竞争同一资源（例如：CPU）的有序调度问题，解决方式为多路复用，多路复用分为时间上的复用和空间上的复用。多道的产生背景是想要在单核CPU的情况下实现多个进程并发执行，具有两大核心特点：
 空间上的复用（多道程序复用内存的空间）：多道程序同时读入内存，等待被CPU执行，即产生了多个进程；进程之间的内存地址空间是相互隔离的，而且这种隔离是物理级别实现的。 时间上的复用（多道程序复用CPU的时间）：正在执行的进程遇到了I/O操作 或 正在执行的进程占用CPU时间过长 或 来了一个优先级更高的进程，操作系统都会强制收回当前进程的CPU使用权限，并将其分配给其他进程。  因此，若要提升程序的执行效率，需要减少或降低I/O操作。
 进程的三种状态（三状态图）#  就绪 运行 阻塞   阻塞和非阻塞# 阻塞和非阻塞指的是程序的两种运行状态。
**阻塞：**遇到I/O就会发生阻塞，程序一旦遇到阻塞就会停在原地，并立刻释放CPU的资源。input、accept、recv、recvfrom、sleep、connect都会引起阻塞，CPU的状态是不工作的。
**非阻塞：**没有遇到I/O操作，或遇到了I/O操作通过某种手段让程序继续执行其他操作，尽可能多的占用CPU。
 同步和异步# 同步和异步指的是提交任务的两种方式。
**同步：**提交完任务后，就在原地等待，直到任务运行完毕后，拿到任务的返回值，才继续执行下一行代码。简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。
**异步：**提交完任务后，不在原地等待，直接执行下一行代码。对于异步调用，调用的返回并不受调用者控制。
 进程的调度算法# 给所有进程分配资源或CPU使用权的方法称之为进程的调度算法。
调度算法有：
 短作业优先 先来先服务（FCFS：First Come First Servie） 多级反馈算法：多个任务队列，优先级从高到低，新来的任务总是优先级最高的，每一个新任务几乎会立即获得一个时间片的执行时间，执行完一个时间片之后就会降级到下一个队列中，并且优先级越高，时间片越短。   进程的开启#  系统初始化的时候开启 一个进程再运行过程中开启子进程 用户交互式请求，而创建的新进程 一个批处理作业的初始化   进程的结束#  正常退出 报错退出 严重错误（非自愿，执行非法指令，如引用不存在的内存） 被其他进程杀死   开启子进程的两种方式# 第一种（函数）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/</guid>
      <description>什么是线程# 线程是进程中的执行单位，是能够被计算机操作系统调度CPU执行的最小单位。
 进程和线程的区别#  进程和线程都可以利用多核。 进程根本就不是一个执行单位，而是一个资源单位，并且是操作系统中的最小资源分配单位，开进程就是在内存中开辟一个空间，将父进程的内容复制过去。一个进程内自带一个线程，而且必须至少有一个线程，线程才是执行单位。 进程在内存中相互隔离；同一进程内的线程共享该进程内资源，不同进程内的线程资源才相互隔离； 进程和线程都存在数据不安全的问题。 创建线程的开销比创建进程小很多，创建线程的速度大约是创建进程速度的100倍；一般情况下我们写的程序，开启的进程数不会超过CPU个数的两倍；而线程的开启没有限制。 进程之间由父子关系，线程之间没有父子关系。 进程可以通过terminate关闭，而线程不能关闭，只能线程执行完毕后才关闭。 在Python中大部分的并发需求都是通过多线程来完成的。   CPython解释器中的GC垃圾回收机制# 在CPython中通过gc线程进行垃圾回收，但由于多核CPU的出现，导致gc线程无法兼顾多个CPU同时调度不同线程线程改变同一个值的引用计数，因此在后来的CPython中加入了GIL（Global Interpreter Lock）全局解释器锁。
 Python GIL（Global Interpreter Lock）全局解释器锁# CPython线程管理机制不是安全的，为了规避多个线程同时操作一个数据导致的安全问题，因此CPython解释器引入了GIL（全局解释器锁），GIL本质就是一把加在解释器上的互斥锁，每一个Python进程内都有一把GIL。同一进程内的所有线程都需要先抢到GIL，才能执行解释器代码，对所有待执行的线程来说，GIL就相当于执行权限，优点是保证了CPython解释器内存管理的线程安全（垃圾回收线程的安全），但会导致同一进程内所有线程同一时刻只能有一个线程执行，而同一时刻只有一个线程争抢成功，即单进程下的多个线程同时只能有一个在运行，也就是说CPython解释器的多线程无法实现并行，也就无法利用多核优势。多个CPU可以提高计算性能，但无法提高I/O性能，因此多个CPU在I/O操作上毫无优势和作用。不同进程的线程不会争抢同意把GIL，只有同一进程的多个线程才会争抢同一把GIL。即，线程本身是可以利用多核的，但由于CPython解释器的垃圾回收机制，导致线程无法利用多核。
在CPython解释器中如果想用到多核优势的话（例如计算密集型程序），就需要开多进程，如果是I/O密集型程序使用多线程。由于PyPy与CPython使用的同一中GC垃圾回收机制，因此，PyPy也无法通过多线程使用多核CPU，但JPython由于GC垃圾回收机制与Java相同，因此JPython可以通过多线程使用多核CPU。
 线程互斥锁与GIL的区别# 二者都是互斥锁，但GIL是加到解释器上的，作用于全局，自定义互斥锁作用域局部。
单进程内的所有线程都会抢GIL，单进程内只有一部分线程会抢自定义互斥锁。
 开启线程的两种方式# 方式一：（常规用法）
from threading import Thread def task(name): print(F&amp;#39;{name}is running...&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: t = Thread(target=task, args=(&amp;#39;子线程&amp;#39;,)) t.start() print(&amp;#39;***主线程***&amp;#39;)  方式二：（自定义类，继承Thread类）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>协程# 协程是程序级别的概念，操作系统根本就没有协程的概念
协程的本质就是一条线程，可以实现多个任务在一条线程上来回切换。协程可以规避I/O操作对程序执行效率的影响，也就是说当CPU调用线程执行任务，遇到I/O或阻塞时，保存这个任务的执行状态，然后让这条线程切换到其他任务上执行，使线程的利用率最大化。
协程对任务的切换是基于用户级的，因此能够感知到的I/O操作（例如socket、网页请求等）是用户级别的，而线程的任务是系统级的，因此线程能够感知的I/O操作（例如文件操作等）更为细腻。
使用协程可以减轻操作系统的负担。
使用协程可以为程序多争取一些CPU的时间片进行任务处理，提高程序执行效率。
 单线程下实现并发# 并发指的是多个任务看起来是同时运行的。
并发实现的本质是：切换 + 保存状态
协程遇到I/O效率才高，纯计算时因为有任务的切换，所以效率反而相比串行效率低。
协程主要用来提升单线程下的线程效率。
 能够让线程在任务间切换并规避I/O的两个模块# gevent模块：利用C语言写的greenlet底层模块完成的切换，并实现了自动规避I/O的功能。
asyncio模块：利用Python中yield底层语法完成的切换，并实现了自动规避I/O的功能，asyncio模块是基于python原生的协程概念，asyncio模块出现在Python 3.4中，在Python 3.5中，专门为协程提供了两个内置关键字：aysnc和await。yield from和send的出现，其实就是为了更好的实现协程。
 协程的gevent模块用法示例# gevent模块是第三方模块，需要单独安装才可使用，可以写协程版的并发Socket Server端
import gevent from gevent import monkey # 需要在导入time之前导入，并执行monkey.patch_all() monkey.patch_all() # 通过monkey.patch_all()，让gevent识别支持的阻塞 import time def func(): # 带有I/O操作的任务写在函数中 print(&amp;#39;Start func!&amp;#39;) time.sleep(1) # 又遇到阻塞，会切换任务，阻塞完毕，继续执行 print(&amp;#39;Stop func!&amp;#39;) g_1 = gevent.spawn(func) # 提交func给gevent g_2 = gevent.spawn(func) # 提交func给gevent g_3 = gevent.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94/</guid>
      <description>Python之进程、线程和协程的对比#     数据共享性 数据安全性 级别 开销 能否利用多核     进程 数据隔离 数据不安全 系统级 开销大（1） 能   线程 数据共享 数据不安全 系统级 开销小（1/100） 不能   协程 数据共享 数据安全 用户级 开销非常小（与调用函数一样快） 不能     </description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Python/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E8%BF%9B%E7%A8%8B/</guid>
      <description>生产者消费者模型（非常重要）# 模型指的是一种解决问题的套路，目的是为了使生产数据与处理数据达到平衡，使得效率最大化。
生产者消费者模型中包含两类重要角色一类叫生产者，另一类叫消费者：
 生产者：将负责制造数据的称为生产者（生产数据）。通常在生产数据之前需要通过一些代码濑获取数据。 消费者：接收生产者制造出的数据，来做进一步处理，该类任务被比喻成消费者（处理数据）。通常在获取代码之后需要通过一些代码进行数据处理。   实现生产者消费者模型的三要素#  生产者 消费者 队列（队列中存放的是一些消息）   生产者消费者模型的运作方式# 生产者生产数据，放到一个共享的空间，然后消费者取走进行处理。
 生产者消费者模型的实现方式# 由于生产者消费者模型并不局限于某一类技术，因此，有多种实现方式，包括但不限于以下方式：
生产者进程 + 队列 + 消费者进程
 该模型的应用场景#程序中出现明显的两类任务，一类任务负责生产数据，另一类任务是负责处理生产数据的，此时就应该考虑生产者消费者模型。（例如：爬虫）
 使用生产者消费者模型的优势：# 实现了生产者与消费者解耦合 平衡了生产力和消费力，彼此不影响，生产者可以一致不停的生产，消费者可以一致不停的消费，因为二者不再是直接沟通了，而是跟队列沟通  import time import random from multiprocessing import Process,Queue def consumer(name, q): while True: res = q.get() if res == None:break time.</description>
    </item>
    
    <item>
      <title>Python之操作MySQL数据库</title>
      <link>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Python/Python%E4%B9%8B%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>安装PyMySQL模块# pip install pymysql  PyMySQL查询数据# import pymysql # 连接数据库 connection = pymysql.connect(host=&amp;#39;127.0.0.1&amp;#39;, user=&amp;#39;root&amp;#39;, password=&amp;#39;123456&amp;#39;, database=&amp;#39;DB&amp;#39;) # 获取游标对象，cursor=pymysql.cursors.DictCursor 表示返回字典类型的数据 cursor = connection.cursor(cursor=pymysql.cursors.DictCursor) # 需要执行的sql语句，一般情况下Python只操作数据表中的数据，查询用户信息表中的user和password sql = &amp;#39;select * from user_info where user=%sand password=%s;&amp;#39; # 执行MySQL命令，sql后面传入user和password参数，可以防止sql注入 cursor.execute(sql,(user,password)) # 获取执行MySQL命令的一个值 result = cursor.fetchone() # 获取执行MySQL命令的多个值 result = cursor.fetchmany(10) # 获取执行MySQL命令的所有值 result = cursor.fetchall() # 关闭游标对象 cursor.close() # 断开数据库连接 connection.close()  PyMySQL增、删、改数据# import pymysql # 连接数据库 connection = pymysql.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Git/git%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Git/git%E5%9F%BA%E7%A1%80/</guid>
      <description>Git的安装#  官方网站：Git (git-scm.com)
  Fedora
dnf install git  Debian/Ubuntu
add-apt-repository ppa:git-core/ppa apt update -y apt install -y git  Windows
 下载地址：Git - Downloading Package (git-scm.com)
  Git的配置文件#  当前项目配置文件路径：/.git/config，使用git config --local命令进行配置，配置文件仅对当前项目（目录生效） 全局配置文件路径：~/.gitconfig，使用git config --global命令进行配置，配置文件对当前用户生效 系统配置文件路径：/etc/.gitconfig，使用git config --system命令进行配置，配置文件对系统下的所有用户生效   配置文件的优先级：当前项目配置文件-&amp;gt;全局配置文件-&amp;gt;系统配置文件
应用场景：
 配置用户信息     Git的基本操作# 要让Git对一个目录进行版本控制，首先需要在Git Bash（或其他命令行工具）中进入目录
执行初始化命令
git init  查看工作区中文件的管理状态</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Kubernetes/Kubernetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Kubernetes/Kubernetes/</guid>
      <description>Kubernetes（K8S）# Kubernetes的基本概念# Pod# Pod是Kubernetes中能够被运行的最小逻辑单元（原子单元） 一个Pod里面可以运行多个容器，他们共享UTS+NET+IPC名称空间 可以把Pod理解成豌豆荚，而同一个Pod中的每一个容器都是一颗颗的豌豆 一个Pod中运行多个容器，又叫边车（SideCar）模式。（边车就是侉子摩托）   Pod控制器# Pod控制器是Pod启动的一种模式，用来保证在Kubernetes中启动的Pod应始终按照预期运行（副本数、生命周期和健康状态检查等） 虽然Pod可以不通过Pod控制器，单独启动并运行在Kubernetes中，但在生产环境中强烈建议使用Pod控制器控制Pod Kubernetes中提供了众多的Pod控制器，常用的有以下几种：  Deployment DeamonSet ReplicaSet StatefulSet Job Cronjob     Name# 由于Kubernetes内部使用“资源”来定义每一种逻辑概念（功能），故每种“资源”都应该有自己的名称 “资源”有API版本（API Version）、类别（kind）、元数据（metadata）、定义清单（spec）、状态（status）等配置信息 “名称”通常定义在“资源”的“元数据（metadata）”信息里   Namespace# 随着项目的增多、人员的增加、集群规模的扩大，需要一种能够隔离Kubernetes内各种“资源”的方法，这就是Namcespace（名称空间） Namespace可以理解为把Kubernetes的内部资源进行了分组，类似于一个公司的各个部门（行政、人力、财务、研发、销售等） 不同Namespace内的“资源”，名称可以相同，相同Namespace内的同种“资源”，“名称”不能相同（可以理解为A机房中的服务器不能有相同的编号，但是B机房中的服务器可以跟A机房中的服务器的编号相同） 合理的使用Kubernetes的Namespace，使得集群管理源能够更好的对交付到Kubernetes中的服务进行分类管理和浏览 Kubernetes中默认存在的Namespace有：default、kube-system、kube-public 查询Kubernetes中特定的“资源”要带上相应的Namespace   Label# 标签是Kubernetes特色的管理方式，便于分类管理资源对象 一个标签可以对应多个资源，一个资源也可以有多个标签，他们是多对多的关心 一个资源拥有多个标签，可以实现不同维度的管理 标签的组成：key = value 与标签类似的，还有一种“注解（annotaions）”   Lable选择器# 给资源打上标签后，可以使用标签选择器过滤指定标签 标签选择器目前有两个：基于等值关系（等于、不等于）和基于合关系（属于、不属于、存在） 许多资源支持内嵌标签选择字段  matchLable matchExpressions     Service# 在Kubernetes的世界里，虽然每一个Pod都会被分配一个单独的IP地址，但这个IP地址会随着Pod的销毁而消失，Pod是有生命周期的，每一次Pod的变更，其IP地址都会随之而变，随之而来的问题就是其流量如何调度，而Service（服务）就是用来解决这个问题的 一个Service可以看作一组提供相同服务Pod的对外访问接口，而Service作用于哪些Pod是通过标签选择器来定义的 Service工作在OSI网路参考模型的第四层，只能进行第四层的网络调度，表现形式是：IP+端口   Ingress# Ingress是Kubernetes集群里工作在OSI网路参考模型的第七层，对外暴露的接口是应用层接口，而Service只能进行第四层的网络调度，Ingress可以调度不同业务域、不同URL访问路径的业务流量 Ingress是kubernetes的标准资源类型之一，也是一种核心资源，它其实就是一组基于域名和URL路径，把用户的请求转发至指定Service资源的一种规则 Ingress可以将集群外部的请求流量转发至集群内部，从而实现服务暴露 Ingress控制器能够监听Ingress资源，然后根据Ingress规则匹配路由、调度流量的一个组件 常用的Ingress控制器的实现软件：  Ingress-nginx HAProxy Traefik ……     RBAC#  Kubernetes自1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://Huang-CH.github.io/docs/Linux/Debian/Debian%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/Debian/Debian%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>Debian系统常用配置# apt命令#    命令 取代的命令 命令的功能     apt install apt-get install 安装软件包   apt remove apt-get remove 移除软件包   apt purge apt-get purge 移除软件包及配置文件   apt update apt-get update 刷新存储库索引   apt upgrade apt-get upgrade 升级所有可升级的软件包   apt autoremove apt-get autoremove 自动删除不需要的包   apt full-upgrade apt-get dist-upgrade 在升级软件包时自动处理依赖关系   apt search apt-cache search 搜索应用程序   apt show apt-cache show 显示装细节   apt list / 列出包含条件的包（已安装，可升级等）   apt edit-sources / 编辑源列表     解决控制台显示乱码问题# apt install locales dpkg-reconfigure locales  重新登录或重启系统后生效</description>
    </item>
    
    <item>
      <title>C&#43;&#43;编程基础</title>
      <link>https://Huang-CH.github.io/docs/C&#43;&#43;/C&#43;&#43;%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/C&#43;&#43;/C&#43;&#43;%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
      <description>C++简介# C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持面向过程、面向对象编程和泛型编程。
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
 C++的开发工具# C++常用的开发工具有Microsoft Visual Studio和Jetbrains CLion。
 C++的基础语法# HelloWorld# // 引入iostream库 #include &amp;lt;iostream&amp;gt; // 调用名称空间std内定义的所有标识符 using namespace std; int main() { // 输出&amp;#34;Hello,World!&amp;#34;，并换行  cout &amp;lt;&amp;lt; &amp;#34;Hello,World!&amp;#34; &amp;lt;&amp;lt; endl; // 将程序在此处暂停,等待任意输入后,再继续执行后续代码  system(&amp;#34;pause&amp;#34;); // 程序正常退出  return 0; }  注释# 单行注释：// 描述信息 多行注释：/* 描述信息 */</description>
    </item>
    
    <item>
      <title>CentOS 7借助系统存储管理器管理LVM</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E5%80%9F%E5%8A%A9%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86LVM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E5%80%9F%E5%8A%A9%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86LVM/</guid>
      <description>安装系统存储管理器
sudo yum install system-storage-manager  查看关于现有磁盘存储设备、存储池、LVM卷和存储快照的信息
sudo ssm list  将一个新的物理磁盘（例如： /dev/sdb）添加到现有的存储池（比如 centos）中
sudo ssm add -p &amp;lt;pool-name&amp;gt; &amp;lt;device&amp;gt;  如果你在存储池中有额外空间，可以扩大存储池中现有的磁盘卷
sudo ssm resize -s [size] [volume] 例如：需要给home挂载点增加 100G 的空间
sudo ssm resize -s +100G /dev/centos_centos7/home  使用 xfs_growfs 来扩展现有的 XFS 文件系统
sudo xfs_growfs /dev/centos_centos7/home  </description>
    </item>
    
    <item>
      <title>CentOS 7搭建FTP服务器</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>安装并启动 FTP 服务# 安装 vsftpd
yum install vsftpd -y  启动 vsftpd
service vsftpd start  启动后，可以看到系统已经监听了 21 端口：
netstat -nltp | grep 21  此时，访问 ftp://127.0.0.1 就可浏览机器上的 /var/ftp 目录了。
 配置 FTP 权限# 目前 FTP 服务登陆允许匿名登陆，也无法区分用户访问，我们需要配置 FTP 访问权限
  了解V SFTP 配置 vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：
 vsftpd.conf 为主要配置文件 ftpusers 配置禁止访问 FTP 服务器的用户列表 user_list 配置用户访问控制    阻止匿名访问和切换根目录
匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：
# 禁用匿名用户 anonymous_enable=NO # 禁止切换根目录 chroot_local_user=YES 编辑完成后，按 Ctrl + S 保存配置，重新启动 FTP 服务，如：</description>
    </item>
    
    <item>
      <title>CentOS 7搭建Git服务器</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。此实验以 CentOS 7 x64 的系统为环境，搭建 git 服务器。
 下载安装 Git# 安装依赖库和编译工具
为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具
yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel  安装编译工具
yum install gcc perl-ExtUtils-MakeMaker  下载 Git
选一个目录，用来放下载下来的安装包，这里将安装包放在 /usr/local/src 目录里
cd /usr/local/src 到官网找一个新版稳定的源码包下载到 /usr/local/src 文件夹里
wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz  解压和编译
解压下载的源码包
tar -zvxf git-2.10.0.tar.gz 解压后进入 git-2.10.0 文件夹
cd git-2.10.0  执行编译
make all prefix=/usr/local/git  编译完成后, 安装到 /usr/local/git 目录下
make install prefix=/usr/local/git  配置环境变量# 将 git 目录加入PATH</description>
    </item>
    
    <item>
      <title>CentOS 7搭建Samba服务器</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BASamba%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BASamba%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>安装Samba服务# yum install -y samba samba-common  创建共享文件夹路径# mkdir /root/ShareFiles chmod 777 /root/ShareFiles  修改Samba配置文件# vi /etc/samba/smb.conf  在Samba配置文件的最后加入# [ShareFile] path = /root/ShareFiles available = yes browseable = yes # public = yes # 不需要密码 writable = yes  创建Samba账户(必须是系统中存在的用户)# touch /etc/samba/smbpasswd smbpasswd -a 用户名  重启Samba# /etc/init.d/smbd restart  </description>
    </item>
    
    <item>
      <title>CentOS 7搭建Yum服务器</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAYum%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E6%90%AD%E5%BB%BAYum%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>制作环境# Yum源仓库服务器
IP地址：10.10.10.10
系统版本：CentOS 7.9 2009
 Yum源客户端
IP地址：10.10.10.20
系统版本：CentOS 7.9 2009
  可以使用多种方式搭建内部Yum源仓库，例如：file、ftp、http、https，本环境以http的方式进行内部yum源仓库的搭建。
  更新系统# yum update -y  安装相关依赖和软件# yum install -y make gcc zlib-devel openssl openssl-devel httpd yum-utils createrepo  yum-utils：reposync同步工具 createrepo：编辑Yum库工具 httpd：通过Apache软件提供Web服务，也可以使用Nginx
  更换Yum源的配置文件# 更换CentOS-Base.repo配置文件的内容
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 更换epel.repo配置文件的内容
curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 清空本地源缓存
yum clean all 生成本地源缓存
yum makecache 显示当前有效的Yum源</description>
    </item>
    
    <item>
      <title>CentOS 7配置本地光盘源</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%85%89%E7%9B%98%E6%BA%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%85%89%E7%9B%98%E6%BA%90/</guid>
      <description>检查需要挂载的cdrom设备是否存在
ls /dev/ 创建挂载点文件夹
mkdir /mnt/cdrom 挂载设备
mount /dev/cdrom /mnt/cdrom 检查设备是否挂载成功
df -h 备份/etc/yum.repo.d/文件夹下的所有的文件，并将所有原文件删除
rename .repo .repo.bak * 创建cdrom.repo文件，并添加以下内容
[mycdrom] name=cdrom baseurl=file:///mnt/cdrom enbale=1 gpgcheck=0  gpgcheck的值为0不检查签名，为1则检查签名。
 清理缓存
yum clean all 重新建立缓存
yum makecache </description>
    </item>
    
    <item>
      <title>CentOS 7静默安装Oracle 19c</title>
      <link>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85Oracle-19c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Linux/CentOS/CentOS-7%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85Oracle-19c/</guid>
      <description>基础配置# 修改主机名
hostnamectl set-hostname Oracle  配置hosts文件
vim /etc/hosts 10.10.10.201 oracle  关闭selinux
vim /etc/selinux/config SELINUX=disable  关闭防火墙
systemctl stop firewalld.service systemctl stop firewalld.service  安装依赖
yum -y install compat-libcap1 compat-libstbc++-33 gcc gcc-c++ glibc-devel ksh libaio-devel sysstat elfutils-libelf-devel fontconfig-devel libxcb smartmontools libX11 libXau libXtst libXrender libXrender-devel  通过脚本创建Oracle用户组
vim CreatUserGroup.sh #!/bin/bash groupadd oinstall groupadd dba groupadd asmdba groupadd backupdba groupadd dgdba groupadd kmdba groupadd racdba groupadd oper useradd -g oinstall -G dba,asmdba,backupdba,dgdba,kmdba,racdba,oper -m oracle  系统优化# 修改内核参数</description>
    </item>
    
    <item>
      <title>Docker基础</title>
      <link>https://Huang-CH.github.io/docs/Docker/Docker%E5%8D%83%E9%94%8B%E6%95%99%E8%82%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/Docker/Docker%E5%8D%83%E9%94%8B%E6%95%99%E8%82%B2/</guid>
      <description>Docker#  使用Docker容器化封装应用程序的意义：
 Docker引擎统一了基础设施环境（Docker环境）  硬件配置 操作系统版本 运行环境的异构   Docker引擎统一了程序打包方式（Docker镜像） Docker引擎统一了程序部署和运行的方式 （Docker容器）    Docker Install（安装）#  安装Docker的依赖环境
# yum-util 提供 yum-config-manager 功能 # device-mapper-persistent-data、lvm2是devicemapper驱动所依赖 sudo yum install -y yum-utils device-mapper-persistent-data lvm2    配置下载Docker的镜像源
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    安装Docker-CE
# Docker-CE是Docker的社区版，默认安装最新版本的Docker sudo yum makecache fast # 将服务器上的软件包信息在本地缓存一份，用来提高搜索安装软件的速度 sudo yum install -y docker-ce docker-ce-cli containerd.io  注意： 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://Huang-CH.github.io/docs/MySQL/MySQL/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/MySQL/MySQL/</guid>
      <description>MySQL相关产品介绍#   Oracle MySQL Cloud Service（Commercial）
商业付费软件，基于MySQL企业版和Oracle云服务提供企业级的MySQL数据库服务。
  MySQL Enterprise Edition（Commercial）
商业付费软件，除了提供MySQL数据库服务之外，又包含了connector（程序连接接口）、partition（分区表）、企业级的monitor（监控）、HA（高可用）、backup（备份）、Scalability（扩展）等服务。
  MySQL Cluster CGE（Commercial）
商业付费软件，基于MySQL Cluster和企业版拥有的各项功能提供企业级的高并发、高吞吐量的数据库服务。
  MySQL Community Edition（Free）
免费社区版，提供基础的数据库服务和其他衍生服务。
  MySQL Cluster（但市场中很少使用，口碑不好）
基于MySQL数据库而实现的集群服务，自身能提供高并发、高负载等特性。
  MySQL Fabric
官方提供的关于MySQL数据库高可用和数据分片的解决方案。
  MySQL Connectors
为应用程序提供JDBC/ODBC等访问MySQL数据库的接口服务。
     MySQL版本介绍# 各操作系统与MySQL版本兼容性参照表：https://www.mysql.com/support/supportedplatforms/database.html
 MySQL安装# 安装版本的选择#  首先需要考虑生产环境中的其他MySQL数据库的版本，优先部署与生产其他MySQL一致的版本。 如果是全新部署，则一般会选择安装最新版本。 生产环境不要选择Development Release，应该选择General Availability Release。   二进制文件安装#  官方文档链接：https://dev.</description>
    </item>
    
    <item>
      <title>PostgreSQL</title>
      <link>https://Huang-CH.github.io/docs/PostgreSQL/PostgreSQL/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Huang-CH.github.io/docs/PostgreSQL/PostgreSQL/</guid>
      <description>简介# PostgreSQL简称PG或PGSQL，是使用C和C++语言开发的，开源的，关系型数据库，支持多种操作系统平台，是一种比较好的Oracle数据库替代方案。
 官方网站：https://www.postgresql.org
中文社区：http://www.postgres.cn
  安装# Yum Repository#  PostgreSQL: Linux downloads (Red Hat family)
 # Install the repository RPM: sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-9-x86_64/pgdg-redhat-repo-latest.noarch.rpm # Disable the built-in PostgreSQL module: sudo dnf -qy module disable postgresql # Install PostgreSQL: sudo dnf install -y postgresql14-server # Optionally initialize the database and enable automatic start: sudo /usr/pgsql-14/bin/postgresql-14-setup initdb sudo systemctl enable postgresql-14 sudo systemctl start postgresql-14  Apt Repository#  PostgreSQL: Linux downloads (Debian)</description>
    </item>
    
  </channel>
</rss>
